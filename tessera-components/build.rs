use std::{
    collections::{HashMap, HashSet},
    env,
    error::Error,
    fmt::Write as _,
    fs, io,
    path::{Path, PathBuf},
};

use zip::ZipArchive;

const STYLES: &[(&str, &str)] = &[
    ("filled", "filled"),
    ("outlined", "outlined"),
    ("round", "round"),
    ("sharp", "sharp"),
    ("two-tone", "two_tone"),
];

const ICON_ARCHIVE: &str = "assets/material_icons/material_icons.zip";
const ICON_MANIFEST: &str = "assets/material_icons/material_icons.manifest";
const ICON_OUT_DIR: &str = "material_icons";

struct IconEntry {
    style: &'static str,
    func: String,
    doc_name: String,
    path: String,
}

fn main() -> Result<(), Box<dyn Error>> {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let archive_path = manifest_dir.join(ICON_ARCHIVE);
    let manifest_path = manifest_dir.join(ICON_MANIFEST);
    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    let extract_dir = out_dir.join(ICON_OUT_DIR);

    println!("cargo:rerun-if-changed={ICON_ARCHIVE}");
    println!("cargo:rerun-if-changed={ICON_MANIFEST}");

    extract_archive(&archive_path, &extract_dir)?;
    let manifest_entries = read_manifest_entries(&manifest_path)?;

    let mut entries: Vec<IconEntry> = Vec::new();
    let mut used_func_sets: HashMap<&'static str, HashSet<String>> = HashMap::new();

    for rel_path in manifest_entries {
        let (style, doc_name) = split_manifest_entry(&rel_path)?;
        let func = {
            let used_funcs = used_func_sets.entry(style).or_default();
            make_func_name(&doc_name, used_funcs)
        };
        let include_path = format!("{ICON_OUT_DIR}/{rel_path}");
        entries.push(IconEntry {
            style,
            func,
            doc_name,
            path: include_path,
        });
    }

    let mut generated = String::new();
    writeln!(
        generated,
        "// @generated by tessera-components/build.rs; do not edit."
    )?;
    writeln!(generated, "use std::sync::Arc;")?;
    writeln!(generated, "use crate::icon::IconContent;")?;
    writeln!(generated, "use crate::material_icons::load_icon_bytes;")?;
    writeln!(
        generated,
        "use crate::pipelines::image_vector::command::ImageVectorData;"
    )?;

    for (style, module) in STYLES {
        let style_entries: Vec<_> = entries.iter().filter(|e| e.style == *style).collect();

        writeln!(
            generated,
            "/// Material Design `{style}` style icons as content helpers."
        )?;
        writeln!(generated, "pub mod {module} {{")?;
        writeln!(generated, "    use super::*;")?;
        for entry in &style_entries {
            let func = &entry.func;
            writeln!(generated, "    /// # {func}")?;
            writeln!(
                generated,
                "    ///\n    /// Return the Material Design `{raw}` icon content in the `{style}` style.",
                raw = entry.doc_name,
                style = style
            )?;
            writeln!(
                generated,
                "    ///\n    /// ## Usage\n    ///\n    /// Use with [`crate::icon::IconArgs`] and [`crate::icon::icon`]."
            )?;
            writeln!(generated, "    ///")?;
            writeln!(generated, "    #[inline]")?;
            writeln!(generated, "    pub fn {func}() -> IconContent {{")?;
            writeln!(
                generated,
                "        let data: Arc<ImageVectorData> = load_icon_bytes(include_bytes!(concat!(env!(\"OUT_DIR\"), \"/{path}\")));",
                path = entry.path
            )?;
            writeln!(generated, "        IconContent::from(data)")?;
            writeln!(generated, "    }}")?;
        }

        writeln!(generated, "}}")?;
    }

    fs::write(out_dir.join("material_icons.rs"), generated)?;
    Ok(())
}

fn extract_archive(archive_path: &Path, extract_dir: &Path) -> Result<(), Box<dyn Error>> {
    if extract_dir.exists() {
        fs::remove_dir_all(extract_dir)?;
    }
    fs::create_dir_all(extract_dir)?;

    let file = fs::File::open(archive_path)?;
    let mut archive = ZipArchive::new(file)?;
    for i in 0..archive.len() {
        let mut entry = archive.by_index(i)?;
        let name = entry.name();
        if entry.is_dir() {
            continue;
        }
        if !name.ends_with(".svg") {
            continue;
        }
        let out_path = extract_dir.join(name);
        if let Some(parent) = out_path.parent() {
            fs::create_dir_all(parent)?;
        }
        let mut outfile = fs::File::create(out_path)?;
        io::copy(&mut entry, &mut outfile)?;
    }
    Ok(())
}

fn read_manifest_entries(manifest_path: &Path) -> Result<Vec<String>, Box<dyn Error>> {
    let content = fs::read_to_string(manifest_path)?;
    let mut entries: Vec<String> = content
        .lines()
        .map(str::trim)
        .filter(|line| !line.is_empty())
        .map(str::to_string)
        .collect();
    entries.sort();
    Ok(entries)
}

fn split_manifest_entry(entry: &str) -> Result<(&'static str, String), Box<dyn Error>> {
    let mut parts = entry.splitn(2, '/');
    let style = parts.next().unwrap_or_default();
    let file_name = parts
        .next()
        .ok_or_else(|| format!("invalid icon manifest entry: {entry}"))?;
    let doc_name = Path::new(file_name)
        .file_stem()
        .ok_or_else(|| format!("invalid icon manifest entry: {entry}"))?
        .to_string_lossy()
        .into_owned();
    let style = STYLES
        .iter()
        .find(|(key, _)| *key == style)
        .map(|(key, _)| *key)
        .ok_or_else(|| format!("unknown icon style in manifest entry: {entry}"))?;
    Ok((style, doc_name))
}

fn make_func_name(name: &str, used: &mut HashSet<String>) -> String {
    let mut parts = Vec::new();
    let mut current = String::new();
    for ch in name.chars() {
        if ch.is_ascii_alphanumeric() {
            current.push(ch);
        } else if !current.is_empty() {
            parts.push(current.clone());
            current.clear();
        }
    }
    if !current.is_empty() {
        parts.push(current);
    }
    if parts.is_empty() {
        parts.push("icon".to_string());
    }

    let mut func = parts.join("_").to_ascii_lowercase();
    func.push_str("_icon");
    if func
        .chars()
        .next()
        .map(|c| c.is_ascii_digit())
        .unwrap_or(false)
    {
        func.insert_str(0, "icon_");
    }
    if is_keyword(&func) {
        func.insert_str(0, "r#");
    }
    let mut suffix = 2;
    while used.contains(&func) {
        let candidate = format!("{func}_{suffix}");
        suffix += 1;
        if !used.contains(&candidate) {
            func = candidate;
            break;
        }
    }
    used.insert(func.clone());
    func
}

fn is_keyword(s: &str) -> bool {
    matches!(
        s,
        "as" | "break"
            | "const"
            | "continue"
            | "crate"
            | "else"
            | "enum"
            | "extern"
            | "false"
            | "fn"
            | "for"
            | "if"
            | "impl"
            | "in"
            | "let"
            | "loop"
            | "match"
            | "mod"
            | "move"
            | "mut"
            | "pub"
            | "ref"
            | "return"
            | "Self"
            | "self"
            | "static"
            | "struct"
            | "super"
            | "trait"
            | "true"
            | "type"
            | "unsafe"
            | "use"
            | "where"
            | "while"
            | "async"
            | "await"
            | "dyn"
            | "abstract"
            | "become"
            | "box"
            | "do"
            | "final"
            | "macro"
            | "override"
            | "priv"
            | "typeof"
            | "unsized"
            | "virtual"
            | "yield"
            | "try"
    )
}
