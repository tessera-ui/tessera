pub mod router;
pub mod task_handles;
mod tokio_runtime;

use std::{
    any::Any,
    sync::{Arc, OnceLock},
};

use dashmap::DashMap;

static REGISTRY: OnceLock<ShardRegistry> = OnceLock::new();

/// Trait for shard state that can be auto-injected into `shard component`.
pub trait ShardState: Any + Send + Sync {
    fn life_cycle(&self) -> ShardStateLifeCycle {
        ShardStateLifeCycle::Shard
    }
}

/// Describes the lifecycle of this ShardState.
///
/// The lifecycle of ShardState can be divided into two types:
///
/// 1. Application: ShardState exists for the lifetime of the application and will not be destroyed.
/// 2. Shard: ShardState's lifecycle matches the navigation target, meaning it will be destroyed when the page is popped.
#[derive(Debug, PartialEq, Eq)]
pub enum ShardStateLifeCycle {
    /// ShardState exists for the lifetime of the application and will not be destroyed.
    Application,
    /// ShardState's lifecycle matches the navigation target, meaning it will be destroyed when the page is popped.
    Shard,
}

impl<T> ShardState for T where T: 'static + Send + Sync + Default {}

pub struct ShardRegistry {
    shards: DashMap<String, Arc<dyn ShardState>>,
}

impl ShardRegistry {
    /// Get the singleton instance of the shard registry.
    ///
    /// Should only be called by macro, not manually.
    pub fn get() -> &'static Self {
        REGISTRY.get_or_init(|| ShardRegistry {
            shards: DashMap::new(),
        })
    }

    /// Get or initialize and get a shard state, and provide it to the closure `f` as `Arc<T>`. The state type must implement `ShardState`.
    ///
    /// This function should never be called manually; it should be automatically generated by the `#[shard]` macro.
    ///
    /// # Safety
    ///
    /// This function is unsafe because it uses an evil method to cast `Arc<dyn ShardState>` to `Arc<T>`.
    pub unsafe fn init_or_get<T, F, R>(&self, id: &str, f: F) -> R
    where
        T: ShardState + Default + 'static,
        F: FnOnce(Arc<T>) -> R,
    {
        let shard_ref = self
            .shards
            .entry(id.to_string())
            .or_insert_with(|| Arc::new(T::default()));

        // Clone to increase the reference count, ensuring the raw pointer is valid
        let arc_clone = shard_ref.value().clone();

        // Unsafe cast Arc<dyn ShardState> -> Arc<T>
        let arc_t = unsafe {
            let raw_dyn: *const dyn ShardState = Arc::as_ptr(&arc_clone);
            let raw_t = raw_dyn as *const T;
            Arc::from_raw(raw_t)
        };

        // Clone again to return, keeping the reference count
        let ret = arc_t.clone();

        // Forget arc_t to avoid decreasing the reference count on drop
        std::mem::forget(arc_t);

        f(ret)
    }

    pub(crate) fn with_mut_dyn<F, R>(&self, id: &str, f: F) -> R
    where
        F: FnOnce(Arc<dyn ShardState>) -> R,
    {
        let shard_ref = self.shards.get(id).expect("Shard not found");
        f(shard_ref.value().clone())
    }
}
