//! Stack-based routing utilities for shard components.
//!
//! Each `#[shard]` function generates a `*Destination` type that implements
//! [`RouterDestination`]. These destinations are managed in a LIFO stack.
//!
//! # Responsibilities
//!
//! * Maintain an ordered stack (`route_stack`) of active destinations
//! * Expose [`push`] / [`pop`] helpers that also manage shard state lifetimes
//! * Remove per‑shard state from the registry when a destination whose lifecycle is
//!   `ShardStateLifeCycle::Shard` is popped
//! * Keep routing logic minimal; rendering happens when the top destination's
//!   `exec_component()` is invoked every frame by `router_root`
//!
//! # Typical Usage
//!
//! ```rust,ignore
//! // Navigate forward
//! tessera_ui::router::push(HomeScreenDestination { /* fields */ });
//! // Navigate back
//! tessera_ui::router::pop();
//! ```
//!
//! # Related
//!
//! * `#[shard]` macro – generates the `*Destination` structs + optional state injection
//! * `tessera_ui::router::router_root` – executes the current top destination each frame
use std::sync::OnceLock;

use parking_lot::RwLock;

use crate::{ShardRegistry, ShardStateLifeCycle};

static ROUTER: OnceLock<RwLock<Router>> = OnceLock::new();

pub struct Router {
    /// Current route stack
    route_stack: Vec<Box<dyn RouterDestination>>,
}

impl Router {
    fn new() -> Self {
        Self {
            route_stack: Vec::new(),
        }
    }

    /// Execute a closure with exclusive mutable access to the router.
    ///
    /// This is the only interior way mutations are performed; higher-level helpers
    /// like [`push`] / [`pop`] wrap this.
    pub fn with_mut<F, R>(f: F) -> R
    where
        F: FnOnce(&mut Self) -> R,
    {
        let router = ROUTER.get_or_init(|| RwLock::new(Self::new()));
        let mut router = router.write();
        f(&mut router)
    }

    /// Push a new route destination onto the stack (internal helper).
    pub fn push<T: RouterDestination + 'static>(&mut self, destination: T) {
        self.route_stack.push(Box::new(destination));
    }

    /// Pop the top route destination from the stack.
    ///
    /// Returns `None` if the stack is empty.
    pub fn pop(&mut self) -> Option<Box<dyn RouterDestination>> {
        self.route_stack.pop()
    }

    /// Whether the router is empty.
    pub fn is_empty(&self) -> bool {
        self.route_stack.is_empty()
    }

    /// Get the current top route destination, used for route component display.
    pub fn last(&self) -> Option<&dyn RouterDestination> {
        self.route_stack.last().map(|v| &**v)
    }
}

/// Push a new route destination onto the navigation stack.
///
/// Usually called with a `*Destination` struct generated by the `#[shard]` macro.
///
/// # Example
/// ```rust,ignore
/// router::push(ProfilePageDestination { /* fields */ });
/// ```
pub fn push<T: RouterDestination + 'static>(destination: T) {
    Router::with_mut(|router| {
        router.push(destination);
    });
}

/// Pop the current (top) destination from the navigation stack.
///
/// If the popped destination's shard state lifecycle is `ShardStateLifeCycle::Shard`,
/// its state entry is removed from the registry.
///
/// Returns `None` if the stack is empty.
///
/// # Example
///
/// ```
/// # use tessera_ui_shard::router;
/// router::pop();
/// ```
pub fn pop() -> Option<Box<dyn RouterDestination>> {
    let dest = Router::with_mut(|router| router.pop())?;
    let Some(life_cycle) =
        ShardRegistry::get().with_mut_dyn(dest.shard_id(), |state| state.life_cycle())
    else {
        return Some(dest);
    };
    if life_cycle == ShardStateLifeCycle::Shard {
        // Remove per-shard state when destination is discarded
        ShardRegistry::get().shards.remove(dest.shard_id());
    }
    Some(dest)
}

/// A navigation destination produced automatically by the `#[shard]` macro.
///
/// You should not manually implement this trait. Each annotated shard function
/// creates a `*Destination` struct that implements `RouterDestination`.
pub trait RouterDestination: Send + Sync {
    /// Execute the component associated with this destination.
    fn exec_component(&self);
    /// Stable shard identifier used for state registry lookups / cleanup.
    fn shard_id(&self) -> &'static str;
}
